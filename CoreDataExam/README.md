# 코어 데이터(CoreData)


코어 데이터는 애플이 코코아 개발 환경을 통해 제공하는 **인메모리(In-Memory)** 방식의 데이터 관리 프레임워크이다.
코어데이터를 사용하여 예의 데이터베이스 개발 환경과 유사하게 데이터를 읽고 쓰며 수정하고 삭제할 수 있다.

인메모리 방식인 만큼, 코어 데이터에서 데이터를 다루는 모든 작업은 메모리를 기반으로 동작한다. 즉 코어 데이터를 통해 읽고 쓰는 모든 데이터는 원칙적으로 메모리에 로드된 다음에 처리된다. 메모리에 로드되기 때문에 대량의 읽기와 쓰기 작업에 의한 성능저하에 크게 영향을 끼치지 않는다. 대부분의 작업이 영구 저장소(Persistence Storage)에서 직접 처리되고, 효율성을 위해 읽기 목적의 데이터 일부만 메모리에 올려 놓고 사용하는 데이터베이스와는 구분되는 효율적 특성이다.
인메모리방식임에 불구하고 앱이 종료가 되어도 코어데이터 내부적으로는 파일이나 SQLite 같은 영구 저장소에 보조적으로 데이터를 저장할 수 있기 때문에 데이터가 삭제가 되지않는다.

## 코어 데이터 vs SQLite


|SQLite|<----->|Core Data|
|:---|:---|:---|
|데이터베이스 파일|<----->|데이터 모델 파일|
|테이블|<----->|엔터티|
|컬럼|<----->|어트리뷰트|
|왜래키+조인|<----->|릴레이션|


코어데이터가 사용하는 데이터 저장구조는 SQLite 와 상당히 유사하다. 
코어데이터는 데이터베이스 처럼 구조화된 데이터를 영구 저장소에 저장하고, 이를 검색하거나 정렬할 수 있는 수단을 제공한다. 게대가 데이터를 정규화할 수 있으며, 빠른 검색을 위해 인덱스를 생성할 수도 있다. 

> 코어데이터는 데이터베이스? SQLite의 래퍼클래스?

결론부터 말하면 코어데이터는 데이터베이스로 보면 안된다. 코어데이터는 영구 저장소로 SQLite 대신 바이너리 파일을 사용할 수 있을 뿐만 아니라 영구 저장소를 아예 사용하지 않고 순수하게 인메모리 방식으로 만 사용하는 것도 가능하기 때문에 데이터베이스의 한 종류 혹은 SQLite의 래퍼라고 말하는 것은 어렵다.

코어데이터를 다룰때 사용하는 코드 형식은 [DAO 패턴](https://github.com/gaki2745/Youngjun-iOS-Studio/tree/master/DAOPatternExam) 스타일과 매우 유사하다. SQL 문을 포함한 DB 처리 코드를 모두 DAO 클래스 내부에 숨기고 뷰 컨트롤러에서는 DAO 클래스의 메소드만 호출하는 방식으로 사용했던 것 처럼, 코어 데이터에서도 뷰컨트롤러는 단지 **관리 객체 컨텍스트(Managed Object Context)** 객체를 통해 필요한 메소드만 호출하면된다. 관리 객체 컨텍스트는 코어 데이터에서 만들어 제공해 주기 떄문에 직접 정의할 필요가 없는 것이 DAO 패턴과 차이점이다.

코어 데이터에서는 각각의 레코드를 **관리 객체(Managed Object)** 라고 하는데, 이 관리 객체는 [VO패턴](https://genesis8.tistory.com/214) 유사한 형태로 정의된 클래스 인스턴스에 할당된 상태로 사용된다. 이를 **MO 패턴**이라고 한다.
MO 클래스의 프로퍼티를 엔터티의 각 어트리뷰트와 직접 연결 시키는 방식을 사용하는데 이 방식을 [ORM 매핑](https://jayzzz.tistory.com/66)이라고 한다.


> ORM 매핑
"Object - Relational Mapping" 데이터베이스와 객체 지향 프로그래밍 언어 사이의 비호환 데이터를 반환하는 프로그래밍 기법


## 코어 데이터에 대한 이해


### 객체 그래프 관리자(Object Graph Manager)

애플 공식문서에 따르면 코어 데이터는 **"애플리케이션에서 모델(Model) 계층의 객체를 관리하는 데 사용하는 프레임워크이자, 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는 객체 그래프 관리자(Object Graph Manager"** 로 정의된다.


#### 객체 그래프(Object Graph)란?

코어 데이터는 영구 저장소에 저장된 각각의 레코드를 읽어들인 다음, 독립적인 객체 형태로 만들어 낸다. 데이터를 다루는 행위는 코어 데이터에서 모두 **객체 단위**로 이루어진다.
이때 레코드의 데이터가 객체화된 것을 가리켜 '관리되는 객체(Managed Object)', 또는 '관리객체'라고 부른다.


정규화된 데이터 객체는 다른 객체와 참조 관계 하에 있으며, 서로간의 관계를 통해 데이터의 완전성을 보장받을 수 있다. 이때 객체를 하나의 노드로 간주하고, 서로 간의 연관 관계를 릴크로 이어보면 다양하게 연결되는 복합적인 그래프 형태의 도형을 얻게 되는데, 이것이 바로 객체 그래프이다.

![image](https://user-images.githubusercontent.com/33486820/54890932-edc7fb80-4eee-11e9-8b8b-9936325d75a3.png)

코어 데이터가 객체 그래프의 관리를 담당하는 것은, **객체 A를 객체 B와 연결할 수 있으며 이 연결을 통해 A와 B는 영속적으로 동기화 된다** 는 것을 뜻한다. 객체 A 에서 업데이트가 발생하면 이에 연결된 객체 B에서도 연간된 데이터의 업데이트가 수행된다. 또한 한쪽에서 객체를 삭제하면 연결을 타고 연이어 객체 객체 B에서도 관련된 데이터의 삭제가 발생하도록 처리가 가능하다.


코어데이터는 전체적으로는 데이터베이스와 비슷한 기능을 제공하지만, 엄밀하게 말해 데이터 저에 관련된 기능을 제공하는 프레임워크라고 할 수 있다. 또한 데이터를 객체로 다루며, 정규화된 데이터 사이의 참조 관계를 바탕으로 한쪽 객체에서 발생한 변경 내용을 다른 쪽 객체에서도 전파하는 등 객체 간 관계의 일관성을 유지하는 객체 그래프 관리자로서의 특징을 가진다.



## 코어 데이터의 구조


코어 데이터는 다층 구조로 이루어진 프레임워크로, 각 층을 담당하는 핵심 객체들이 서로 밀접한 연관성을 가진 채 상호작용한다. 전체적으로 코어 데이터는 개발자와 영구 저장소 사이를 이어주는 프레임워크이기 때문에 FMDB 라이브러리와도 일맥 상통하는 브븐이 많다.


### 관리 객체(Managed Object)


관리 객체는 코어 데이터에서 데이터를 저장하기 위해 생성하는 인스턴스이다. 관계형 데이터베이스에서 테이블의 행이나 레코드와 유사하다 코어 데이터는 모든 레코드를 객체화하여 다루기 때문에, 독립된 객체로 동작한다. 이때, 레코드를 구성하는 각 칼럼들은 관리 객체의 속성이 된다.

레코드 두개를 읽기 위해서는 두개츼 관리 객체가 필요하고, 새로운 레코드를 추가할 때 역시 데이터를 담을 관리 객체가 생성되어야 한다. 코어 데이터에서 사용되는 관리객체는 모두 **NSManagedObject 클래스**나 또는 그 하위 클래스의 인스턴스 이며, 생성된 관리 객체들은 모두 관리 객체 컨텍스트에 담겨 관리된다.


### 관리 객체 컨텍스트(Managed Object Context)


관리 객체 컨텍스트는 코어 데이터에서 가장 핵심적인 객체로, 크게 두가지 역할을 담당한다

1. 관리 객체를 담거나 생성, 삭제할 수 있다. 모든 관리 객체는 컨텍스트에 담겨 관리되는데 데이터를 읽거나 쓰고, 수정하는 작업은 모두 컨텍스트를 통해 처리된다. 코어 데이터가 다루는 모든 데이터는 메모리에 로드된 상태로 처리되는데 이떄의 메모리는 곧 컨텍스트를 의미한다.

2. 영구 저장소 및 저장소 코디네이터에 대한 관리자이다. 컨텍스트는 영구 저장소 코디네이터와 매우 밀접하게 연결되어 있으며, 읽기 및 쓰기 요청을 처리한다. 하지만 이 작업은 모두 컨텍스트 내부에서 처리하기 때문에, 특정 메소드를 호출하는 것만으로 데이터를 읽거나 쓰는 데 필요한 모든 작업을 처리할 수 있다

### 영구 저장소 코디네이터(Persistent Store Coordinator)


영구 저장소 코디네이터는 컨텍스트와 직접 데이면서 다양한 영구 저장소들의 접근을 조정하고, 해당 저장소에 대한 실제 입출력을 담당한다.

코디네이터는 단일 컨텍스트와 연결되어 애플리케이션이 전달하는 각종 요청을 처리하는데, 예를들어 필요한 객체가 아직 컨텍스트에 로딩 되지 않았다면 코딩네이터는 캔텍스트로부터 요청을 받아 영구저장소에 데이터를 찾고, 이를 컨텍스트에 전달하여 메모리에 로드 하는 방식이다. 이 과정에서 코디네이터는 미리 정의된 관리 객체 모델을 사용하여 인스턴스를 생성하고 여기에 읽어온 데이터를 담아 전달하고, 이렇게 생성된 인스턴사 바로 관리 객체이다.
이 과정은 컨텍스트 객체와 영구 저장소 사이에서 자동으로 처리되기 때문에 개발자가 직접 코디네이터에 접속하여 뭔가를 처리해야하는 경우는 거의 없다.

### 관리 객체 모델(Managed Object Model)


코어 데이터에서 테이블에 대응되는 엔터티(Entitiy)의 구조를 정의하는 객체인 동시에 이 스키마를 바탕으로 정의된 MO 패턴의 모델 클래스를 가리킨다. 관리 객체에 저장된 데이터 구조에 대한 정보를 담고있다. 관리 객체 모델은 Xcode에서 설계한 엔터티로부터 생성된다.

> 관리 객체(Object)와 관리 객체모델(Object Model) 구분

- **관리 객체 모델** 클래스이자 형식이고 구조인 반면, **관리 객체**는 이를 바탕으로 생성되는 인스턴스이다.

- 관리 객체는 데이터 조작이나 저장 등에 관여하는 실질적인 객체이지만, 관리 객체 모델은 데이터를 조작하거나 저장하는 동작에는 영향을 미치지 않으며 대신 관리 객체의 각 요소를 제대로 담을 수 있도록 저장 데이터를 구조화 하는 데에만 사용된다.


### 영구 객체 저장소(Persistant Object Store)


코어 데이터를 사용할 때 데이터가 저장되는 저장소 환경을 의미한다. 내부적으로 코어 데이터는 데이터에 대한 변경 사항을 해석하여 영구 저장소에 저장한다.

- 인메모리 저장소 타입(NSInmemoryStoreType)

- 플랫 바이너리 저장소 타입(NSBinaryStoreType)

- XML 저장소 타입(NSXMLStoreType)

- SQLite 데이터베이스(NSSQLiteStoreType): 가장 많이 선택하는 영구 저장소 타입, 일부만 로딩하기 때문에 메모리에 객체 그래프가 완전히 로딩되어 있지 않을 수 있지만 일반적인 사용 범위에서는 크게 문제되지 않는 수준이다. iOS 프로젝트에서 코어 데이터가 기본으로 채택하는 방식이다.


영구 저장소 계층은 추상화되어 있기 때문에, 어떤 타입을 선택하더라도 애플리케이션에서 데이터를 처리하기 위해 사용하는 코어 데이터 API는 달라지지 않는다.



SQLite 저장소 타입은 iOS에서 기본 타입으로 사용되긴 하지만, 몇 가지 문제를 안고 있다. 이는 부분적인 업데이트를 수행하는 저장 방식 때문으로, 대표적인 문제가 처리 속도와 원자성이다. 전체 내용을 그대로 파일에 쭉 밀어 넣는 전체 업데이트와 달리 수정해야 하는 부분을 찾아서 해당 내용을 삭제하고, 여기에다 새로운 내용을 작성해 넣어야 하기 때문이다. 게다가 부분 업데이트로 내용을 변경하는 과정에서 오류가 발생하거나 제대로 진행되지 않을 경우 전체 파일의 손상이 생길 수도 있다.


### 인메모리(In-Momory) DB
 

> 코어데이터는 우선 메모리에 로딩이 되어야하는 인메모리 방식


코어 데이터는 인메모리 방식으로 동작하는 프레임워크이다. 사용하려는 모든 데이터는 우선 메모리에 로딩되는 과정을 거친 다음에야 비로소 사용할 수 있으며, 데이터를 읽거나 쓰고 수정하며 삭제하는 모든 작업은 메모리에 로딩된 데이터를 대상으로 이루어진다. 코어 데이터에서 파일이나 SQLite 등의 영구 저장소에 데이터를 저장하는 과정은 선택적이며, 사용자가 명시적으로 저장 메소드를 호출했을 때만 실행된다. 변경 내역을 영구 저장소에 반영하는 과정을 가리켜 커밋(commit) 또는 동기화(Synchronize)라고 부르는데, 커밋이 발생하기 전까지 변경된 데이터는 메모리에서만 존재한다.


이 방식의 장점으로는 **빠른 처리 속도와 성능의 향상**이다. 온디스크(On-Disk) 방식처럼 매번 디스크에 직접 작성하거나 읽어오지 않아도 되기 때문에 상대적으로 I/O가 적게 발생하며, 비즈니스 로직 수행 과정에서 발생하는 데이터의 변경 내역을 모두 메모리 수준에서 처리한 후 최종 결과만 영구 저장소에 반영하면 되기 때문에 여러 번 반복해서 읽거나 쓰더라도 성능에는 문제가 거의 생기지 않는다. 특히 디스크에 보존하지 않아도 되는 임시 데이터를 가공할 경우 코어 데이터는 데이터베이스에 비해 훨씬 빠른 속도로 데이터를 다룰 수 있다.


> SQLite를 사용시 


코드를 작성하는 방식에 따라 성능의 저하가 생길 수 있는데 영구 저장소로 SQLite를 사용하는 경우, 디스크에 읽기/쓰기를 하는 SQLite의 기본 오버헤드에다 코어 데이터와 SQLite 간의 데이터 컨버전을 위한 오버헤드가 추가되기 때문에 매 작업마다 커밋을 하게 되면 오히려 SQLite만 사용하는 것보다 느려질 수 있다.


### 데이터의 교환 및 저장 메커니즘


데이터 교환 방식은 영구 저장소에서 레코드를 로딩할 때에는 저장된 레코드를 로딩할 때에는 저장된 레코드를 그대로 읽어 관릴 객체로 만들어 내고, 반대로 관리 객체를 영구 저장소에 저장할 때에는 메모리상에서 수정된 객체가 그대로 영구 저장소에 반영되는 식이다. 따라서 데이터 항목 하나하나를 처리하기 위해 구문을 작성할 필요는 없으며, 프로퍼티 리스트를 저장할 때처럼 개별 데이터를 일일이 저장할 필요도 없다. 그냥 메모리상에서 컨텍스트에 로드된 관리 객체를 수정한 뒤 커밋하면 변경된 사항이 통째로 영구 저장소에 반영된다.


영구 저장소로 SQLite를 선택한 상태에서 컨텍스트의 관리 객체를 저장소에 커밋할 때에는  **차등저장(Differencail Save) 메커니즘**이 사용된다. 이 매커니즘은 매번 데이터 전체를 커밋하는 대신 마지막 저장 이후에 변경 부분만 커밋하는 방식으로, 빠르고 가볍게 처리할 수 있다.


코어 데이터를 사용하면서 생성,수정 또는 삭제된 데이터에 대해 최종적으로 save() 메소드를 호출하면 메모리상의 관리 객체 변경 내용이 그대로 영구 저장소에 커밋된다. 이를 커밋하지 않고 앱을 종료할 경우 데이터의 변경 내역은 반영되지 않은 채로 버려지기 때문에, 변경 사항이 발생했다면 적절한 시기에 반드시 save() 메소드를 호출하면 변경된 내역을 커밋해 주어야한다.


### 코어 데이터의 한계


데이터베이스의 기능 중에서 코어 데이터가 하지 못하는 기능의 한계까 존재한다.

- 데이터를 메모리에 로딩하는 과정 없이는 작업이 불가능하다.


코어 데이터는 인메모리 방식을 기반으로 동작하는 프레임워크이다. 메모리에 로딩된 객체에 대해서만 수정이 가능하기 때문에, 먼저 객체를 메모리에 로딩해 두어야 한다. 데이터를 삭제하는 과정 역시 마찬가지이다. 이 같은 과정이 반복되면 메모리 사용량이 늘어나고 이는 결국 성능의 하락으로 이어질 수 있다.

많은 수의 객체들을 수정하거나 삭제해야 할 경우에는 `NSFetchRequest` 객체에 정의된 `returnDistinctResults`, `propertiesToFetch` 등의 속성을 적극 활용하여 객체의 전체 프로퍼티를 모두 불러오는 것을 지양하고, 주기적으로 `NSManagedObjectContext#refresh(_:mergeChanges:)` 메소드를 호출하여 변경 내역이 없는 객체들을 해제하며, 컨텍스트를 영구 저장소에 커밋한 후에는 로딩된 모든 객체를 메모리에서 해제해 주는 등의 방법을 사용하여 메모리를 효율적으로 관리해 주어야 한다.


- 데이터 로직을 다루는 데에 한계가 있다.


관계형 데이터베이스에서 동일 테이블에 중복된 값의 입력을 방지하는 “Unique” 키와 같은 기능을 코어 데이터에서는 제공되지 않기 때문에 중복 값의 입력을 방지하려면 애플리케이션에서 비즈니스 로직을 통해 처리해 주어야 한다.

이는 구조적 특성 때문이다. 관리 객체 모델을 서브 클래싱하는 경우 원하는 대로 데이터 프로퍼티에 대한 오버라이드가 가능한데, 이를 통해 변경된 내용을 코어 데이터가 확인할 수 있는 방법은 없다. 즉, 상위 클래스에서 특정 값의 중복 입력을 방지했다하더라도 이를 서브 클래싱한 하위 클래스에서 중복 입력이 가능하도록 오버라이드해 버리면 이를 알 방법도, 제지할 수단도 없다는 것이다.

이처럼 코어 데이터는 자신의 영역을 벗어나는 데이터 로직에 대해서는 관여할 수 없기 때문에, 이를 비즈니스 로직으로 처리해야 한다.



- 멀티 스레드, 멀티 유저를 지원하지 않는다.


코어 데이터는 원칙적으로 싱글 스레드만 지원한다. 한 번에 하나의 작업만 처리할 수 있다는 뜻이다.

단일 작업에서 처리 성능을 향상시키기 위함인데, 멀티 스레딩 방식으로 동작할 때에는 한쪽에서 작업하고 있는 동안 해당 영역을 다른 스레드가 침범하지 못하도록 락(Lock)을 걸어야 하는데, 이 락은 종종 데이터베이스 성능 저하의 원인이 된다. 락을 걸지 않음으로써 훨씬 빠르게 데이터를 처리할 수 있다.









